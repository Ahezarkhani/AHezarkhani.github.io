<!DOCTYPE html>
<html>
<head>
  <title>15-112: Fundamentals of Programming</title>
  <link rel="stylesheet" type="text/css" href="../css/reset.css">
  <link rel="stylesheet" type="text/css" href="../css/bootstrap.min.css">
  <link rel="stylesheet" type="text/css" href="../css/112.css">
  <link rel="stylesheet" type="text/css" href="../css/112-highlight-style.css">
  <script src="../js/jquery-2.1.4.min.js"></script>
  <script src="../js/highlight.pack.js"></script>
  <script src="../js/bootstrap.min.js"></script>
  <script id="112-script" src="../js/112.js"></script>
  <base target="_self">
</head>
<body>

  <div class="navbar">
    15-112 <br> Spring 18
    <br><br><a target="_self" href="../index.html">Home</a>
    <br><br><a target="_self" href="../syllabus.html">Syllabus</a>
    <br><br><a target="_self" href="../schedule.html">Schedule</a>
    <br><br><a target="_self" href="../gallery.html">Gallery</a>
    <br><br><a target="_self" href="../staff.html">Staff</a>
    <br><br><a target="_self" href="../piazza.html">Piazza</a>
    <br><br><a target="_self" href="../autolab.html">Autolab</a>
    <br><br><a target="_blank" href="../oh-queue.html">OH Queue</a>
  </div>

  <div class="content">
    <h1>
      CMU 15-112: Fundamentals of Programming and Computer Science<br>
      Class Notes: Efficiency
    </h1>
    <hr>

    <ol>
      <li><a href="#bigO"><b>Big-O</b></a></li>
    </li><li><a href="#fnFamilies"><b>Common Function Families</b></a></li>
  </li><li><a href="#efficiency"><b>Efficiency</b></a></li>
</li><li><a href="#bigIdea"><b>The Big Idea</b></a></li>
</li><li><a href="#examples"><b>Examples</b></a>
  <ol>
    <li><a href="#sequentialNestingComp"><b>Sequences, Nesting, and Composition</b><br></a></li>
    <li><a href="#builtins"><b>Python Builtins</b><br></a></li>
  </li><li><a href="#searching"><b>Searching</b></a></li>
</li><li><a href="#sorting"><b>Sorting</b></a></li>
</li><li><a href="#sumOfSquares"><b>sumOfSquares Examples</b><br></a></li>
</ol></li>
</ol>

<hr>

<ol>

  <li><a name="bigO"></a><b>Big-O</b>
    <span class="play-video"
    data-src="https://www.youtube.com/embed/yuy9kM32lWY"></span>
    <ol>
      <li>Describes behavior of a function as the size of its input grows
      </li><li>Informally (for 15112):  ignore all lower-order terms and constants
      </li><li>Formally (after 15112):  see
        <a target="_blank" href="https://en.wikipedia.org/wiki/Big_O_notation#Formal_definition">here</a>
      </li><li>A few examples in math functions:
        <ul>
          <li>3n<sup>2</sup> - 2n + 25 is O(n<sup>2</sup>)
          </li><li>30000n<sup>2</sup> + 2n - 25 is O(n<sup>2</sup>)
          </li><li>0.00000000001n<sup>2</sup> + 123456789n is O(n<sup>2</sup>)
          </li><li>10nlog<sub>17</sub>n + 25n - 17 is O(nlogn)
          </li></ul>
        </ol>

      </li><br><li><a name="fnFamilies"></a><b>Common Function Families</b>
        <span class="play-video"
        data-src="https://www.youtube.com/embed/-N3np7lBtHA"></span>
        <ol>
          <li>Constant O(1)
          </li><li>Logarithmic O(logn)
          </li><li>Square-Root O(n<sup>0.5</sup>)
          </li><li>Linear  O(n)
          </li><li>Linearithmic, Loglinear, or quasilinear  O(nlogn)
          </li><li>Quadratic  O(n<sup>2</sup>)
          </li><li>Exponential  O(k<sup>n</sup>)
          </li></ol>
        </li>
        <br>
        <b>Graphically (Images borrowed from
          <a target="_blank" href="http://science.slc.edu/~jmarshall/courses/2002/spring/cs50/BigO/index.html">here</a>):</b><br>
          <img border="0" src="big-oh1.gif" width="552" height="411"><br>
          <br>
          <img border="0" src="big-oh2.gif" width="547" height="402"><br>
          <br>
          <img border="0" src="big-oh3.gif" width="549" height="400"><br>
        </li>

      </li><br><li><a name="efficiency"></a><b>Efficiency</b>
        <span class="play-video"
        data-src="https://www.youtube.com/embed/xxf3RzXLgd0"></span><br>
        When we say the program runs in O(N), we mean...
        <ul>
          <li>N is the size of our input
            <ul>
              <li>For a string s, N = len(s)</li>
              <li>For a list lst, N = len(lst) (also true for sets, dictionaries, and other collections)</li>
              <li>For an integer n, N = n</li>
            </ul>
          </li>
          <li>We can technically calculate Big-O for a number of program attributes, like time, space, bandwidth, etc. But in this class, we mainly care about time.</li>
          <li>For time, we usually measure algorithmic steps rather than elapsed time (These share the same Big-O, but algorithmic steps are easier to precisely describe and reason over)</li>
          <ul>
            <li>Algorithmic steps could be single lines of computation, or comparisons and swaps in a list, etc</li>
            <li>Can verify by timing your code's execution with: time.time()</li>
          </ul>
        </li>
        <li>Note that you can measure worst-case or average case, or even other cases such as best case (which often is trivial to compute and not very useful in practice). For 15-112, we often omit this term (which is a notable simplification that you will not see in future courses), and we nearly always mean worst-case, which is quite useful and generally easier to compute than average-case.</li>
      </ul>
      <br><li><a name="bigIdea"></a><b>The Big Idea</b>
        <span class="play-video"
        data-src="https://www.youtube.com/embed/gEDvl3v5d5w"></span>
        <ul>
          <li>Each function family grows much faster than the one before it!
          </li><li>And: on modern computers, any function family is usually efficient enough on small n, so we only care about large n
          </li><li>So...  Constants do not matter nearly as much as function families
          </li><li>Practically...
           <ul><li>Do not prematurely or overly optimize your code
           </li><li>Instead:  <b>think algorithmically!!!</b>
           </li></ul>
         </li></ul>

       </li><br><li><a name="examples"></a><b>Examples</b>
        <ol>

          <li><a name="sequentialNestingComp"></a><b>Sequences, Nesting, and Composition</b>
            <span class="play-video"
            data-src="https://www.youtube.com/embed/n6LeHpTColY"></span>
            <ul>
              <li><b>Sequencing</b><br>
                <div class="python-code">
                  # what is the total cost here?
                  L = [ 52, 83, 78, 9, 12, 4 ]   # assume L is an arbitrary list of length N 
                  L.sort()                       # This is O(NlogN)
                  L.sort(reverse=True)           # This is O(NlogN)
                  L[0] -= 5                      # This is O(1)
                  print(L.count(L[0]) + sum(L))  # This is O(N) + O(N)
                </div>

              </li><br><li><b>Nesting</b><br>
                <div class="python-code">
                  # what is the total cost here?
                  L = [ 52, 83, 78, 9, 12, 4 ]   # assume L is an arbitrary list of length N 
                  for c in L:                    # This loop's body is executed O(N) times
                  L[0] += c                  # This is O(1)
                  L.sort()                   # This is O(NlogN)
                  print(L)                       # This is O(N) (why?)
                </div>
              </li><br><li><b>Composition</b><br>
                <div class="python-code">
                  # what is the total cost here?
                  def f(L):             # assume L is an arbitrary list of length N 
                  L1 = sorted(L)    # This is O(NlogN)
                  return L1         # This is O(1)

                  def g(L):             # assume L is an arbitrary list of length N
                  L1 = L * len(L)   # This is O(N**2) (why?)
                  return L1         # This is O(1)

                  L = [ 52, 83, 78, 9, 12, 4 ]   # assume L is an arbitrary list of length N 
                  L = f(g(L))                    # What is the Big-O of this?
                  print(L)                       # This is O(N**2) (why?)
                </div>
              </li>
            </ul>
          </li>

        </li><br><li><a name="builtins"></a><b>Python Builtins</b>
          <span class="play-video"
          data-src="https://www.youtube.com/embed/eI_PYaGhtFo"></span><br>
          The efficiency of the built-in functions in Python will affect the efficiency of the functions they are used in. We do not expect you to memorize the builtin efficiencies; instead, you may look them up in the table provided below when needed. We will include the relevant subset of this table on quizzes and exams.<br><br>

          <table>
            <thead>
              <tr><td colspan="3" align="center"><b>General</b></td></tr>
              <tr>
                <td align="center">Function/Method</td>
                <td align="center">Complexity</td>
                <td align="center">Code Example</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Print</td>
                <td align="center">O(N)</td>
                <td><pre># where N is the size of the input
                print(input)</pre></td>
              </tr>
              <tr>
                <td>Range in Iteration</td>
                <td align="center">Number of iterations = (end - start)/step</td>
                <td><pre>for i in range(start, end, step):...</pre></td>
              </tr>
            </tbody>
            <thead>
              <tr><td colspan="3" align="center"><b>Strings: s is a string with N characters</b></td></tr>
              <tr>
                <td align="center">Function/Method</td>
                <td align="center">Complexity</td>
                <td align="center">Code Example</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Len</td>
                <td align="center">O(1)</td>
                <td><pre>len(s)</pre></td>
              </tr>
              <tr>
                <td>Membership</td>
                <td align="center">O(N)</td>
                <td><pre>"a" in s</pre></td>
              </tr>
              <tr>
                <td>Get single character</td>
                <td align="center">O(1)</td>
                <td><pre>value = s[index]</pre></td>
              </tr>
              <tr>
                <td>Get slice</td>
                <td align="center">O(end - start)</td>
                <td><pre>s[start:end]</pre></td>
              </tr>
              <tr>
                <td>Get slice with step</td>
                <td align="center">O((end - start)/step)</td>
                <td><pre>s[start:end:step]</pre></td>
              </tr>
              <tr>
                <td>Chr() and Ord()</td>
                <td align="center">O(1)</td>
                <td><pre>chr(s)
                ord(s)</pre></td>
              </tr>
              <tr>
                <td>Concatentation</td>
                <td align="center">O(len(s1) + len(s2))</td>
                <td><pre>s3 = s1 + s2</pre></td>
              </tr>
              <tr>
                <td>Character Type Methods</td>
                <td align="center">O(N)</td>
                <td><pre>s.isalnum()
                  s.isalpha()
                  s.isdigit()
                  s.islower()
                  s.isspace()
                s.isupper()</pre></td>
              </tr>
              <tr>
                <td>String Edit Methods</td>
                <td align="center">O(N)</td>
                <td><pre>s.lower()
                  s.upper()
                  s.replace()
                s.strip()</pre></td>
              </tr>
              <tr>
                <td>Substring Search Methods</td>
                <td align="center">O(N)</td>
                <td><pre>s.count()
                  s.startswith()
                  s.endswith()
                  s.find()
                s.index()</pre></td>
              </tr>
            </tbody>
            <thead>
              <tr><td colspan="3" align="center"><b>Lists: L is a list with N elements</b></td></tr>
              <tr>
                <td align="center">Function/Method</td>
                <td align="center">Complexity</td>
                <td align="center">Code Example</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Len</td>
                <td align="center">O(1)</td>
                <td><pre>len(L)</pre></td>
              </tr>
              <tr>
                <td>Append</td>
                <td align="center">O(1)</td>
                <td><pre>L.append(value)</pre></td>
              </tr>
              <tr>
                <td>Extend</td>
                <td align="center">O(K)</td>
                <td><pre># len(a) = K
                L.extend(a)</pre></td>
              </tr>
              <tr>
                <td>Concatentation with +=</td>
                <td align="center">O(K)</td>
                <td><pre># len(a) = K
                L += a</pre></td>
              </tr>
              <tr>
                <td>Concatentation with +</td>
                <td align="center">O(N + K)</td>
                <td><pre># len(a) = K
                L = L + a</pre></td>
              </tr>
              <tr>
                <td>Membership Check</td>
                <td align="center">O(N)</td>
                <td><pre>item in L</pre></td>
              </tr>
              <tr>
                <td>Pop Last Value</td>
                <td align="center">O(1)</td>
                <td><pre>L.pop()</pre></td>
              </tr>
              <tr>
                <td>Pop Intermediate Value</td>
                <td align="center">O(N)</td>
                <td><pre>L.pop(index)</pre></td>
              </tr>
              <tr>
                <td>Count values in list</td>
                <td align="center">O(N)</td>
                <td><pre>L.count(item)</pre></td>
              </tr>
              <tr>
                <td>Insert</td>
                <td align="center">O(N)</td>
                <td><pre>L.insert(index, value)</pre></td>
              </tr>
              <tr>
                <td>Get value</td>
                <td align="center">O(1)</td>
                <td><pre>value = L[index]</pre></td>
              </tr>
              <tr>
                <td>Set value</td>
                <td align="center">O(1)</td>
                <td><pre>L[index] = value</pre></td>
              </tr>
              <tr>
                <td>Remove</td>
                <td align="center">O(N)</td>
                <td><pre>L.remove(value)</pre></td>
              </tr>
              <tr>
                <td>Get slice</td>
                <td align="center">O(end - start)</td>
                <td><pre>L[start:end]</pre></td>
              </tr>
              <tr>
                <td>Get slice with step</td>
                <td align="center">O((end - start)/step)</td>
                <td><pre>L[start:end:step]</pre></td>
              </tr>
              <tr>
                <td>Sort</td>
                <td align="center">O(N log (N))</td>
                <td><pre>L.sort()
                sorted(L)</pre></td>
              </tr>
              <tr>
                <td>Multiply</td>
                <td align="center">O(N*D)</td>
                <td><pre>#where D is an int
                A = L*D</pre></td>
              </tr>
              <tr>
                <td>Minimum</td>
                <td align="center">O(N)</td>
                <td><pre>min(L)</pre></td>
              </tr>
              <tr>
                <td>Maximum</td>
                <td align="center">O(N)</td>
                <td><pre>max(L)</pre></td>
              </tr>
              <tr>
                <td>Copy</td>
                <td align="center">O(N)</td>
                <td><pre>copy.copy(L)</pre></td>
              </tr>
              <tr>
                <td>Deep Copy</td>
                <td align="center">O(N*M)</td>
                <td><pre># where L is a 2D list with N rows and M cols
                copy.deepcopy(L)</pre></td>
              </tr>
            </tbody>
            <thead>
              <tr><td colspan="3" align="center"><b>Sets: s is a set with N elements</b></td></tr>
              <tr>
                <td align="center">Function/Method</td>
                <td align="center">Complexity</td>
                <td align="center">Code Example</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Len</td>
                <td align="center">O(1)</td>
                <td><pre>len(s)</pre></td>
              </tr>
              <tr>
                <td>Membership</td>
                <td align="center">O(1)</td>
                <td><pre>elem in s</pre></td>
              </tr>
              <tr>
                <td>Adding an Element</td>
                <td align="center">O(1)</td>
                <td><pre>s.add(elem)</pre></td>
              </tr>
              <tr>
                <td>Removing an Element</td>
                <td align="center">O(1)</td>
                <td><pre>s.remove(elem)
                s.discard(elem)</pre></td>
              </tr>
              <tr>
                <td>Union</td>
                <td align="center">O(len(s) + len(t))</td>
                <td><pre>s|t</pre></td>
              </tr>
              <tr>
                <td>Intersection</td>
                <td align="center">O(min(len(s), len(t)))</td>
                <td><pre>s&amp;t</pre></td>
              </tr>
              <tr>
                <td>Difference</td>
                <td align="center">O(len(s))</td>
                <td><pre>s - t</pre></td>
              </tr>
              <tr>
                <td>Clear</td>
                <td align="center">O(len(s))</td>
                <td><pre>s.clear()</pre></td>
              </tr>
              <tr>
                <td>Copy</td>
                <td align="center">O(len(s))</td>
                <td><pre>s.copy()</pre></td>
              </tr>
            </tbody>
            <thead>
              <tr><td colspan="3" align="center"><b>Dictionaries: d is a dictionary with N key-value pairs</b></td></tr>
              <tr>
                <td align="center">Function/Method</td>
                <td align="center">Complexity</td>
                <td align="center">Code Example</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Len</td>
                <td align="center">O(1)</td>
                <td><pre>len(d)</pre></td>
              </tr>
              <tr>
                <td>Membership</td>
                <td align="center">O(1)</td>
                <td><pre>key in d</pre></td>
              </tr>
              <tr>
                <td>Get Item</td>
                <td align="center">O(1)</td>
                <td><pre>value = d[key]
                d.get(key, defaultValue)</pre></td>
              </tr>
              <tr>
                <td>Set Item</td>
                <td align="center">O(1)</td>
                <td><pre>d[key] = value</pre></td>
              </tr>
              <tr>
                <td>Delete Item</td>
                <td align="center">O(1)</td>
                <td><pre>del d[key]</pre></td>
              </tr>
              <tr>
                <td>Clear</td>
                <td align="center">O(N)</td>
                <td><pre>d.clear()</pre></td>
              </tr>
              <tr>
                <td>Copy</td>
                <td align="center">O(N)</td>
                <td><pre>d.copy()</pre></td>
              </tr>
            </tbody></table>
            <br>

            For a more complete list, see
            <a target="_blank" href="https://wiki.python.org/moin/TimeComplexity">here</a>

          </li><br><li><a name="searching"></a><b>Searching</b>
            <span class="play-video"
            data-src="https://www.youtube.com/embed/GgASMq61lWo"></span>
            <ul>
              <li><b>Linear search</b>
                <ul><li>Basic idea: check each element in turn
                </li><li>Use: find an element in an unsorted list
                </li><li>Cost: O(N)
                </li></ul>
              </li><li><b>Binary search</b>
                <ul><li>Basic idea: in a <b>sorted list</b>, check middle element, eliminate half on each pass
                </li><li>Uses:
                  <ul><li>Find an element in a sorted list
                  </li><li>Number-guessing game (eg: guess a random number between 1 and 1000)
                  </li><li>Find a root (zero) of a function with bisection (adapted binary search)
                  </li></ul>
                </li><li>Cost: O(logN)
                </li></ul>
              </li></ul>

            </li><br><li><a name="sorting"></a><b>Sorting</b>
              <ol>
                <li><a name="sorting1"></a><b>Sorting Examples</b><br>
                  See <a href="notes-1d-lists-examples.html#sorting">here</a>.

                </li><br>

                <li><b>Sorting Links</b><br>
                  <ul>
                    <li><a target="_blank" href="http://en.wikipedia.org/wiki/Sorting_algorithm">Wikipedia page on Sorting</a></li>
                    <li><a target="_blank" href="http://math.hws.edu/TMCM/java/xSortLab/index.html">David Eck's xSortLab applet</a>
                      (or you might try
                      <a target="_blank" href="http://math.hws.edu/TMCM/java/classes/xSortLab.jar">this jar file</a>
                    )</li>
                    <li><a target="_blank" href="http://sorting.at/">Excellent sorting animation website</a></li>
                    <li><a target="_blank" href="https://www.youtube.com/watch?v=kPRA0W1kECg">Sorting algorithm animation video (15 algorithms in 6 minutes)</a></li>
                    <li><a target="_blank" href="http://www.sorting-algorithms.com/">Even more sorting algorithm animations</a></li>
                  </ul>
                </li>

                <br><li><a name="sorting2"></a><b>SelectionSort vs MergeSort</b>
                  <span class="play-video"
                  data-src="https://www.youtube.com/embed/LeHPgNn28us"></span>
                  <ul>

                    <li><b>Definitions</b>
                      <ul>
                        <li>Selection Sort: repeatedly select largest remaining element and swap it into sorted position
                        </li><li>Mergesort:  sort blocks of 1's into 2's, 2's into 4's, etc, on each pass merging sorted blocks into sorted larger blocks
                        </li></ul></li>

                        <li><b>Analysis</b><br>
                          This is mostly informal, and all you need to know for a 112-level analysis of these algorithms.  You can easily find much more detailed and rigorous proofs on the web.
                          <ul>
                            <li><b>selectionsort</b><br>
                              On the first pass, we need N compares and swaps (N-1 compares and 1 swap).<br>
                              On the second pass, we need only N-1 (since one value is already sorted).<br>
                              On the third pass, only N-2.<br>
                              So, total steps are about 1 + 2 + ... + (N-1) + N = N(N+1)/2 = O(N<sup>2</sup>).
                            </li><br><li><b>mergesort</b><br>
                              On each pass, we need about 3N compares and copies (N compares, N copies down, N copies back).<br>
                              So total cost = (3N steps per pass) x (# of passes)<br>
                              After pass 0, we have sorted lists of size 2<sup>0</sup> (1)<br>
                              After pass 1, we have sorted lists of size 2<sup>1</sup> (2)<br>
                              After pass 2, we have sorted lists of size 2<sup>2</sup> (4)<br>
                              After pass k, we have sorted lists of size 2<sup>k</sup> <br>
                              So we need k passes, where N = 2<sup>k</sup><br>
                              So # of passes = k = log<sub>2</sub>N<br>
                              Recall that total cost = (3N steps per pass) x (# of passes)<br>
                              So total cost = (3N)(log<sub>2</sub>N) = O(NlogN).<br>
                              Note: This is the theoretical best-possible Big-O for comparison-based sorting!
                            </li></ul></li>
                          </ul>
                        </ol>
                      </li>

                    </li><br><li><a name="sumOfSquares"></a><b>sumOfSquares Examples</b>
<!--
<span class="play-video"
      data-src="https://www.youtube.com/embed/yZhJaFaClTM"></span>
    -->
    <br>
    Note: Run this code in Standard Python, as it will timeout if you run it in brython.
    <div class="python-code no-viz no-run">
      # The following functions all solve the same problem:
      # Given a non-negative integer n, return True if n is the sum
      # of the squares of two non-negative integers, and False otherwise.

      def f1(n):
      for x in range(n+1):
      for y in range(n+1):
      if (x**2 + y**2 == n):
      return True
      return False

      def f2(n):
      for x in range(n+1):
      for y in range(x,n+1):
      if (x**2 + y**2 == n):
      return True
      return False

      def f3(n):
      xmax = int(n**0.5)
      for x in range(xmax+1):
      for y in range(x,n+1):
      if (x**2 + y**2 == n):
      return True
      return False

      def f4(n):
      xyMax = int(n**0.5)
      for x in range(xyMax+1):
      for y in range(x,xyMax+1):
      if (x**2 + y**2 == n):
      return True
      return False

      def f5(n):
      xyMax = int(n**0.5)
      for x in range(xyMax+1):
      y = int((n - x**2)**0.5)
      if (x**2 + y**2 == n):
      return True
      return False

      def testFunctionsMatch(maxToCheck):
      # first, verify that all 5 functions work the same
      print("Verifying that all functions work the same...")
      for n in range(maxToCheck):
      assert(f1(n) == f2(n) == f3(n) == f4(n) == f5(n))
      print("All functions match up to n =", maxToCheck)

      testFunctionsMatch(100) # use larger number to be more confident

      import time
      def timeFnCall(f, n):
      # call f(n) and return time in ms
      # Actually, since one call may require less than 1 ms,
      # we'll keep calling until we get at least 1 secs,
      # then divide by # of calls we had to make
      calls = 0
      start = end = time.time()
      while (end - start < 1):
      f(n)
      calls += 1
      end = time.time()
      return float(end - start)/calls*1000 #(convert to ms)

      def timeFnCalls(n):
      print("***************")
      for f in [f1, f2, f3, f4, f5]:
      print ("%s(%d) takes %8.3f milliseconds" %
      (f.__name__, n, timeFnCall(f, n)))

      timeFnCalls(1001)  # use larger number, say 3000, to get more accurate timing
    </div>
  </li>
</ol>
</li>
</li>
</ol>
<hr>
</div>
</body>
</html>
